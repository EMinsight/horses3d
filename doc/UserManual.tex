\documentclass[a4paper,10pt]{report}
%\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float} 
\usepackage{multirow}
\usepackage{vmargin}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{subfigure}
\usepackage{afterpage}
\usepackage[calcwidth]{titlesec}
\usepackage{verbatim}
\usepackage[hidelinks]{hyperref}
\usepackage{multicol}
\usepackage{pfnote}
\usepackage{fnpos}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{algorithm,algpseudocode}
\usepackage{epstopdf}
\usepackage{tcolorbox}
\setmarginsrb{2cm}{2cm}{2cm}{2cm}{0cm}{0cm}{0cm}{0.5cm}%{left}{top}{right}{bottom}{headhgt}{}
%\numberwithin{equation}{section}
%Bibliography style:
\bibliographystyle{elsarticle-num}
%\biboptions{sort&compress}
%opening

\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}


\title{\textbf{HORSES3D} \\ A \textbf{H}igh-\textbf{Or}der (DG) \textbf{S}pectral \textbf{E}lement \textbf{S}olver \\ \textbf{User Manual}}
\author{Andr√©s Rueda \\ Many others (future?)}

\begin{document}

\lstset{language=C++}

\maketitle

\tableofcontents

\chapter{Compiling the code}

\begin{itemize}
\item Clone the git repository or copy the source code into a desired folder.

\item Go to the folder Solver.

\item Run configure script.
\begin{lstlisting}[language=bash]
	$ ./configure
\end{lstlisting}
\item Install using the Makefile:
\begin{lstlisting}[language=bash]
	$ make all <<Options>>
\end{lstlisting}
with the desired options (bold are default):

\begin{itemize}
\item MODE=DEBUG/\textbf{RELEASE}
\item COMPILER=ifort/\textbf{gfortran}
\item COMM=PARALLEL/\textbf{SEQUENTIAL}
\item PLATFORM=MACOSX/\textbf{LINUX}
\item ENABLE\_THREADS=NO/\textbf{YES}
\end{itemize}

For example:
\begin{lstlisting}[language=bash]
	$ make all COMPILER=ifort COMM=PARALLEL
\end{lstlisting}

\item If you use \textit{environment modules}, it is advised to use the HORSES3D module file:\\
\begin{lstlisting}[language=bash]
	$ export MODULEPATH=$HORSES_DIR/utils/modulefile:$MODULEPATH
\end{lstlisting}
where \$HORSES\_DIR is the installation directory.
\end{itemize}



\chapter{Input and Output Files}

\section{Input Files}
\begin{itemize}
\item Control file (*.control)
\item Mesh file (*.mesh / *.h5)
\item Polynomial order file (*.omesh)
\item Problem File (ProblemFile.f90)
\end{itemize}

\section{Output Files}
\begin{itemize}
\item Solution file (*.hsol)
\item Horses mesh file (*.hmesh)
\item Boundary information (*.bmesh)
\item Partition file (*.pmesh)
\item Polynomial order file (*.omesh)
\item Monitor files (*.volume / *.surface / *.residuals)
\end{itemize}

\chapter{Running a Simulation}

\section{Control File (*.control) - Overview}
The control file is the main file for running a simulation. A list of all the mandatory keywords for running a simulation and some basic optional keywords is presented in Table \ref{tab:runningkey}. The specific keywords are listed in the other chapters.

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{General keywords for running a case.} \label{tab:runningkey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{General keywords for running a case - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

solution file name   & \textit{CHARACTER}: Path and name of the output file. The name of this file is used for naming other output files. & \textbf{Mandatory\ keyword} \\ \hline

simulation type        & \textit{CHARACTER}: Specifies if NSLITE3D must perform a 'steady-state' or a 'time-accurate' simulation. &  'steady-state'\\ \hline

time integration & \textit{CHARACTER}: Can be 'implicit', 'explicit', or 'FAS'. The latter uses the Full Algebraic Storage (FAS) multigrid scheme, which can have implicit or explicit smoothers. & 'explicit' \\ \hline

polynomial order   & \textit{INTEGER}: Polynomial order to be assigned uniformly to all the elements of the mesh. If the keyword \textit{polynomial order file} is specified, the value of this keyword is overridden. & --* \\ \hline

polynomial order i \

polynomial order j \

polynomial order k & \textit{INTEGER}: Polynomial order in the i, j, or k component for all the elements in the domain. If used, the three directions must be declared explicitly, unless you are using a polynomial order file. If the keyword \textit{polynomial order file} is specified, the value of this keyword is overridden. & --* \\ \hline

polynomial order file  & \textit{CHARACTER}: Path to a file containing the polynomial order of each element in the domain. & --* \\ \hline

restart 			& \textit{LOGICAL}: If .TRUE., initial conditions of simulation will be read from restart file specified using the keyword \textit{restart file name}. & \textbf{Mandatory keyword} \\ \hline

cfl & \textit{REAL}: A constant related with the \textbf{convective} Courant-Friedrichs-Lewy (CFL) condition that the program will use to compute the time step size. & --** \\ \hline

dcfl & \textit{REAL}: A constant related with the \textbf{diffusive} Courant-Friedrichs-Lewy (DCFL) condition that the program will use to compute the time step size. & --** \\ \hline

dt  & \textit{REAL}: Constant time step size.  & --** \\ \hline

final time  & \textit{REAL}: This keyword is mandatory for time-accurate solvers & -- \\ \hline

mesh file name & \textit{CHARACTER}: Name of the mesh file. The currently supported formats are \textit{.mesh} (SpecMesh file format) and \textit{.h5} (HOPR hdf5 file format). & \textbf{Mandatory\ keyword} \\ \hline

mesh inner curves & \textit{LOGICAL}: Specifies if the mesh reader must suppose that the inner surfaces (faces connecting the elements of the mesh) are curved. This input variable only affects the hdf5 mesh reader. & .TRUE. \\ \hline

number of time steps & \textit{INTEGER}: \textit{Maximum} number of time steps that the program will compute.  & \textbf{Mandatory\ keyword} \\ \hline

output interval   & \textit{INTEGER}: In steady-state, this keyword indicates the interval of time steps to display the residuals on screen. In time-accurate simulations, this keyword indicates how often a 3D output file must be stored.  & \textbf{Mandatory\ keyword} \\ \hline

convergence tolerance & \textit{REAL}: Residual convergence tolerance for steady-state cases & \textbf{Mandatory\ keyword} \\ \hline

manufactured solution & \textit{CHARACTER}: Must have the value '2D' or '3D'. When this keyword is used, the program will add source terms for the conservative variables taken into account an exact analytic solution for each primitive variable j ($\rho$, $u$, $v$, $w$, $p$) of the form:\
 
$j = j_C(1) + j_C(2) \sin(\pi j_C(5) x) + j_C(3) \sin(\pi j_C(6) y) + j_C(4) \sin(\pi j_C(7) z) $\

Where $j_C(i)$ are constants defined in the file \textit{ManufacturedSolutions.f90}. Proper initial and boundary conditions must be imposed (see the test case). The mesh must be a unit cube.
  & -- \\ \hline

Number of boundaries & \textit{INTEGER}: Specifies the number of boundaries of the geometry. This keyword must be followed by an equal number of lines in the control file that define the boundary conditions as follows: \ 

\begin{center}
\textit{boundaryName1 boundaryValue1 boundaryType1} \ 

\textit{boundaryName2 boundaryValue2 boundaryType2} \

\textit{...} 
\end{center}
& \textbf{Mandatory keyword} \\ \hline

\multicolumn{3}{p{16.4cm}}{*  One of these keywords must be specified} \\

\multicolumn{3}{p{16.4cm}}{** For Euler simulations, the user must specify either the CFL number or the time-step size. For Navier-Stokes simulations, the user must specify the CFL and DCFL numbers \textbf{or} the time-step size.}

\end{longtable}

\section{Boundary conditions}
Under construction.


\chapter{Restarting a Case}

\begin{table}[htbp]
\caption{Keywords for restarting a case.}
\begin{tabular}{|l|p{10cm}|p{2.2cm}|}
\hline
\multicolumn{1}{|c|}{Keyword} & \multicolumn{1}{c|}{Description} & \multicolumn{1}{c|}{Default value} \\ \hline

restart 			& \textit{LOGICAL}: If .TRUE., initial conditions of simulation will be read from restart file specified using the keyword \textit{restart file name}. & \textbf{Mandatory keyword} \\ \hline

restart file name   & \textit{CHARACTER}: Name of the restart file to be written and, if keyword \textit{restart} = .TRUE., also name of the restart file to be read for starting the simulation. & \textbf{Mandatory\ keyword} \\ \hline

restart polorder & \textit{INTEGER}: Uniform polynomial order of the solution to restart from. This keyword is only needed when the restart solution is of a different order than the current case. & same as case's \\ \hline

restart polorder file & 
			\textit{CHARACTER}: File containing the polynomial orders of the solution to restart from. This keyword is only needed when the restart solution is of a different order than the current case.  &  same as case's\\ \hline

get discretization error of & \textit{CHARACTER}: Path to solution file. This can be used to estimate the discretization error of a solution when restarting from a higher-order solution. & -- \\ \hline

\end{tabular}
\label{tab:restartkey}
\end{table}


\chapter{Implicit Solvers}
\section{General Keywords}
The keywords for the implicit solvers are listed in table \ref{tab:implicitkey}

%\begin{table}[htbp]
%\caption{Keywords for implicit solvers.}
%\begin{tabular}{|l|p{10cm}|p{2.2cm}|}
%\hline
%\multicolumn{1}{|c|}{Keyword} & \multicolumn{1}{c|}{Description} & \multicolumn{1}{c|}{Default value} \\ \hline

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for implicit solvers.} \label{tab:implicitkey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for implicit solvers - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

\textbf{time integration} & \textit{CHARACTER}: This is the main keyword for activating the implicit solvers. The value of it should be set to 'implicit'. & 'explicit' \\ \hline

jacobian flag           & \textit{INTEGER}: Specifies the type of Jacobian matrix to be computed. Options are:\
				\begin{enumerate}
					\item Numerical Jacobian: Uses coloring algorithm for computing Jacobian.
					\item Analytical Jacobian: Being implemented. To date only available for the compressible Euler equations and 'matrix-free smooth' linear solver to compute the blocks of the Jacobian.
					\end{enumerate}
										& 1 \\ \hline

jacobian by convergence & \textit{LOGICAL}: When .TRUE., the Jacobian is only computed when the convergence falls beneath some threshold (see keyfords: blah and blah blah). This improves performance but can introduce big numerical errors for time-accurate simulations.  & .FALSE. \\ \hline

linear solver           & \textit{CHARACTER}: Specifies the linear solver that has to be used. Options are:\ 
				\begin{itemize}
					\item 'petsc': PETSc library Krylov-Subspace methods.
					\item 'pardiso': Intel MKL PARDISO.
					\item 'matrix-free gmres': A matrix-free version of the GMRES algorithm. Can be used without preconditioner or with a recursive GMRES preconditioner using 'preconditioner=GMRES'.
					\item 'smooth': Traditional iterative methods. One can select either 'smoother=WeightedJacobi' or 'smoother=BlockJacobi'.
					\item 'matrix-free smooth': A matrix-free version of the previous solver. Only available eith 'smoother=BlockJacobi'
					\item 'multigrid': .
				\end{itemize}
										& 'petsc'  \\ \hline
print newton info       & \textit{LOGICAL}: If .TRUE., the information of the Newton iterations will be displayed. &  '.FALSE.'\\ \hline
implicit adaptive dt  & \textit{LOGICAL}: Specifies if the time-step should be computed according to the convergence behavior of the Newton iterative method and the linear solver. & .FALSE. \\ \hline
newton tolerance   & \textit{REAL}: Specifies the tolerance for the Newton method. &  $10^{-6}$ or for time-accurate simulations and  $MaxResidual \times 10^{-3}$ for steady-state simulations \\ \hline
    &  &  \\ \hline
    
\end{longtable}

\section{Multigrid}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for the multigrid solver.} \label{tab:multigridKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the multigrid solver - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead


multigrid levels & \textit{INTEGER}: Number of multigrid levels for the computations. & \textbf{Mandatory keyword} \\ \hline

delta n          & \textit{INTEGER}: Interval of reduction of polynomial order for creating coarser multigrid levels.& 1 \\ \hline

multigrid output & \textit{LOGICAL}: If .TRUE., the residuals at the different multigrid levels will be displayed. & .FALSE. \\ \hline
   
    &  &  \\ \hline
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{p-Adaptation Methods}
The p-adaptation methods are used when the p-adaptation region is specified in the control file:\\

\begin{lstlisting}
#define p-adaptation
   Truncation error type = isolated
   truncation error      = 1.d-2
   Nmax                  = [10,10,10]
   Nmin                  = [2 ,2 ,2 ]
   Conforming boundaries = [InnerCylinder,sphere]
   order across faces    = N*2/3   
   increasing            = .FALSE.
   regression files      = .FALSE.
   adjust nz             = .FALSE.
   mode                  = time
   interval              = 1.d0   
   restart files         = .TRUE.
   padapted mg sweeps pre      = 10
   padapted mg sweeps post     = 12
   padapted mg sweeps coarsest = 20
#end
\end{lstlisting}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for the p-adaptation algorithms.} \label{tab:pAdaptationKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the p-adaptation algorithms - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

truncation error type & \textit{CHARACTER}: Can be either "isolated" or "non-isolated". & isolated \\ \hline

truncation error & \textit{REAL}: Target truncation error for the p-adaptation algorithm. & \textbf{Mandatory keyword} \\ \hline

Nmax          & \textit{INTEGER}(3): Maximum polynomial order in each direction for the p-adaptation algorithm. & 
					\textbf{Mandatory keyword} \\ \hline

Nmin          & \textit{INTEGER}(3): Minimum polynomial order in each direction for the p-adaptation algorithm. & 
					[1,1,1] \\ \hline

conforming boundaries & \textit{CHARACTER}(*): Specifies the boundaries of the geometry that must be forced to be conforming after the p-adaptation process.  	  & 
					-- \\ \hline

order across faces &
			\textit{CHARACTER}: Mathematical expression to specify the maximum polynomial order jump across faces. Currently, only $N*2/3$ and $N-1$ are supported. &
					$N-1$ \\ \hline 

increasing & \textit{LOGICAL}: If .TRUE. the multi-stage FMG adaptation algorithm is used. & 
					.FALSE. \\ \hline

regression files &
			\textit{LOGICAL}: If .TRUE., the program writes files containing the information about the lin-log regression procedure that is performed for the $\tau$-estimation extrapolation. The files are stored in the folder \textit{./RegressionFiles/Stage\_XX/}, where \textit{XX} is the adaptation stage number. & 
			 		.FALSE. \\ \hline

adjust nz & 
			\textit{LOGICAL}: If .TRUE., the order accross faces is adjusted i    n the directions xi, eta, and zeta of the face (being zeta the normal direction). If .FALSE., the     order is only adjusted in the xi and eta directions. The adjustment currently consists (hard-cod    ed) in allowing jumps in the polynomial order of at most 1. & 
					.FALSE. \\ \hline

mode & 
			\textit{CHARACTER}: p-Adaptation mode. Can be \textit{steady}, \textit{time} or \textit{iteration}. Steady p-adaptation is performed once at the beginning of a simulation. Unsteady adaptation can be by \textit{time} or by \textit{iteration}. &
					\textit{steady} \\ \hline

interval & 
			\textit{INTEGER/REAL}: In unsteady p-adaptation cases, this keyword specifies the iteration (integer) or time (real) interval for p-adaptation. &
					\textit{huge number} \\ \hline

restart files & 
			\textit{LOGICAL}: If .TRUE., the program writes restart files before and after the p-adaptation. &
					.FALSE. \\ \hline

padapted $\ll \textit{keyword} \gg$ &
			\textit{MULTIPLE}: Specifies control file keywords that should be replaced after the adaptation procedure. Currently, only 'mg sweeps         ', 'mg sweeps pre', 'mg sweeps post', and 'mg sweeps coarsest' are supported. &
					-- \\ \hline

\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Monitors}



\section{Statistics Monitor}
\begin{lstlisting}
#define statistics
   sample interval = 10
#end
\end{lstlisting}

A keyword preceded by @ is used in real-time to signalize the solver what it must do with the statistics computation:

\begin{multicols}{3}
\begin{itemize}
\item @start
\item @pause
\item @stop
\item @reset
\item @dump
\end{itemize}
\end{multicols}

After reading the keyword, the solver performs the desired action and marks it with a star, e.g. @start*.

\section{Probes}

\begin{lstlisting}
#define probe 1
   name     = SomeName
   variable = SomeVariable
   position = [0.d0, 0.d0, 0.d0]
#end
\end{lstlisting}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for probes.} \label{tab:ProbesKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the p-adaptation algorithms - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

name 	& 
			\textit{CHARACTER}: Name of the monitor. & 
							\textbf{Mandatory Keyword} \\ \hline

variable 	& 
			\textit{CHARACTER}: Variable to be monitored. Implemented options are:\
\begin{multicols}{3}
\begin{itemize}
\item pressure
\item velocity
\item u
\item v
\item w
\item mach
\item k
\end{itemize}			
\end{multicols}	
			 & 
							\textbf{Mandatory Keyword} \\ \hline

position 	& 
			\textit{REAL(3)}: Coordinates of the point to be monitored. & 
							\textbf{Mandatory Keyword} \\ \hline
\end{longtable}


\section{Surface Monitors}

\section{Volume Monitors}
Volume monitors compute the average of a quantity in the whole domain. They can be scalars(s) or vectors(v). 

\begin{lstlisting}
#define volume monitor 1
   name     = SomeName
   variable = SomeVariable
#end
\end{lstlisting}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for volume monitors.} \label{tab:VolMonitorsKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the p-adaptation algorithms - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

name 	& 
			\textit{CHARACTER}: Name of the monitor. & 
							\textbf{Mandatory Keyword} \\ \hline

variable 	& 
			\textit{CHARACTER}: Variable to be monitored. The variable can be scalar (s) or vectorial (v). Implemented options are:\
\begin{multicols}{2}
\begin{itemize}
\item[\textbf{(s)}] kinetic energy
\item[\textbf{(s)}] kinetic energy rate
\item[\textbf{(s)}] enstrophy
\item[\textbf{(s)}] entropy
\item[\textbf{(s)}] entropy rate
\item[\textbf{(s)}] mean velocity
\item[\textbf{(v)}] velocity
\item[\textbf{(v)}] momentum
\item[\textbf{(v)}] source
\end{itemize}		
\end{multicols}	
			
			 & 
							\textbf{Mandatory Keyword} \\ \hline


\end{longtable}

\chapter{Advanced User Setup}

Advanced users can have additional control over a simulation without having to modify the source code and recompile the code. To do that, the user can provide a set of routines that are called in different stages of the simulation via the Problem file (\textit{ProblemFile.f90}). A description of the routines of the Problem File can be found in section \ref{sec:ProblemFile}.

\section{Routines of the Problem File: \textit{ProblemFile.f90}} \label{sec:ProblemFile}

\begin{itemize}
\item UserDefinedStartup: Called before any other routines

\item UserDefinedFinalSetup: Called after the mesh is read in to allow mesh related initializations or memory allocations.

\item UserDefinedInitialCondition: called to set the initial condition for the flow. By default it sets an uniform initial condition, but the user can change it.

\item UserDefinedState1, UserDefinedNeumann: Used to define an user-defined boundary condition.

\item UserDefinedPeriodicOperation: Called before every time-step to allow periodic operations to be performed.

\item UserDefinedSourceTermNS: Called to apply source terms to the equation.

\item UserDefinedFinalize: Called after the solution computed to allow, for example error tests to be performed.

\item UserDefinedTermination: Called at the the end of the main driver after everything else is done.
\end{itemize}

\section{Compiling the Problem File}

The Problem Fie file must be compiled using a specific Makefile that links it with the libraries of the code. If you are using the \textit{horses/dev} environment module, you can get templates of the \textit{Problemfile.f90} and \textit{Makefile} with the following commands:

\begin{lstlisting}[language=bash]
	$ horses-get-makefile
	$ horses-get-problemfile
\end{lstlisting}

Otherwise, search the test cases for examples.\\

To run a simulation using user-defined operations, create a folder called SETUP on the path were the simulation is going to be run. Then, store the modified \textit{ProblemFile.f90} and the \textit{Makefile} in SETUP, and compile using:

\begin{lstlisting}[language=bash]
	$ make <<Options>>
\end{lstlisting}
where again the options are:
\begin{itemize}
\item MODE=DEBUG/\textbf{RELEASE}
\item COMPILER=ifort/\textbf{gfortran}
\item COMM=PARALLEL/\textbf{SEQUENTIAL}
\item PLATFORM=MACOSX/\textbf{LINUX}
\item ENABLE\_THREADS=NO/\textbf{YES}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Postprocessing}

For postprocessing the Simulation Results

\section{Visualization with Tecplot Format: \textit{horses2plt}}

HORSES3D provides a script for converting the native binary solution files (*.hsol) into tecplot ASCII format (*.tec), which can be visualized in Pareview or Tecplot. Usage:

\begin{lstlisting}[language=bash]
	$ horses2plt <<SolutionFile.hsol>> <<MeshFile.hsol>> <<Options>>
\end{lstlisting}

The options comprise following flags:

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for volume monitors.} \label{tab:VolMonitorsKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Additional flags for postprocessing with \textit{horses2plt}} \\
\hline
\multicolumn{1}{|c|}{\textbf{Flag}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

--output-order= 	& 
			\textit{INTEGER}: Output order for equispaced nodes. The solution is interpolated in the desired number of points. & 
							Not Present \\ \hline

--dimensionless 	& 
			Specifies that the output quantities must be dimensionless & 
							Not Present  \\ \hline
							
--partition-file= 	& 
			\textit{CHARACTER}: Specifies the path to the partition file (*.pmesh) to export the MPI ranks of the simulation. & 
							Not Present  \\ \hline
							
--boundary-mesh= 	& 
			\textit{CHARACTER}: Specifies the path to the boundary mesh file (*.bmesh) to export the surfaces as additional zones of the Tecplot file. & 
							Not Present  \\ \hline


\end{longtable}

Additionally, depending on the type of solution file, the user can specify additional options.

\subsection{Solution Files (*.hsol)}

For standard solution files, the user can specify which variables they want to be exported to the Tecplot file with the flag:

\begin{lstlisting}[language=bash]
	--output-variables=
\end{lstlisting}

The options are:

\begin{multicols}{5}
\begin{itemize}
\item $Q$ (default)
\item $rho$
\item $u$
\item $v$
\item $w$
\item $p$
\item $T$
\item $Mach$
\item $s$
\item $Vabs$
\item $V$
\item $Ht$
\item $rhou$
\item $rhov$
\item $rhow$
\item $rhoe$
\item $c$
\item $Nxi$
\item $Neta$
\item $Nzeta$
\item $Nav$
\item $N$
\item $Ax\_Xi$
\item $Ax\_Eta$
\item $Ax\_Zeta$
\item $ThreeAxes$
\item $Axes$
\item $mpi\_rank$
\item $gradV$
\item $u\_x$
\item $v\_x$
\item $w\_x$
\item $u\_y$
\item $v\_y$
\item $w\_y$
\item $u\_z$
\item $v\_z$
\item $w\_z$
\item $c\_x$
\item $c\_y$
\item $c\_z$
\item $omega$
\item $omega\_x$
\item $omega\_y$
\item $omega\_z$
\item $omega\_abs$
\item $Qcrit$
\end{itemize}
\end{multicols}

\subsection{Statistics Files (*.stats.hsol)}
Statistics files generate following variables by default:

\begin{multicols}{3}
\begin{itemize}
\item Umean
\item Vmean
\item Wmean
\item Sxx
\item Syy
\item Szz
\item Sxy
\item Sxz
\item Syz
\end{itemize}
\end{multicols}

\section{Extract geometry}
Under construction.

\bibliography{../LaTeX/9_backmatter/library}

\end{document}

