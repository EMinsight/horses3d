\documentclass[a4paper,10pt]{report}
%\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float} 
\usepackage{multirow}
\usepackage{vmargin}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{subfigure}
\usepackage{afterpage}
\usepackage[calcwidth]{titlesec}
\usepackage{verbatim}
\usepackage[hidelinks]{hyperref}
\usepackage{multicol}
\usepackage{pfnote}
\usepackage{fnpos}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{algorithm,algpseudocode}
\usepackage{epstopdf}
\usepackage{tcolorbox}
\setmarginsrb{2cm}{2cm}{2cm}{2cm}{0cm}{0cm}{0cm}{0.5cm}%{left}{top}{right}{bottom}{headhgt}{}
%\numberwithin{equation}{section}
%Bibliography style:
\bibliographystyle{elsarticle-num}
%\biboptions{sort&compress}
%opening

\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}


\title{\textbf{HORSES3D \\ User Manual}}
\author{Andr√©s Rueda \\ Many others (future?)}

\begin{document}

\lstset{language=C++}

\maketitle

\tableofcontents

\chapter{Input and Output Files}

\section{Input Files}
\begin{itemize}
\item Control file (*.control)
\item Mesh file (*.mesh / *.h5)
\item Polynomial order file (*.omesh)
\item Problem File (ProblemFile.f90)
\end{itemize}

\section{Output Files}
\begin{itemize}
\item Solution file
\item Horses mesh file
\item Partition file
\item Polynomial order file
\item Monitor files
\end{itemize}

\chapter{Running a Simulation}
List of all the mandatory keywords for running a simulation and some basic optional keywords. The specific keywords are listed in the other chapters.

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{General keywords for running a case.} \label{tab:runningkey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{General keywords for running a case - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

solution file name   & \textit{CHARACTER}: Path and name of the output file. The name of this file is used for naming other output files. & \textbf{Mandatory\ keyword} \\ \hline

simulation type        & \textit{CHARACTER}: Specifies if NSLITE3D must perform a 'steady-state' or a 'time-accurate' simulation. &  'steady-state'\\ \hline

time integration & \textit{CHARACTER}: Can be 'implicit', 'explicit', or 'FAS'. The latter uses the Full Algebraic Storage (FAS) multigrid scheme, which can have implicit or explicit smoothers. & 'explicit' \\ \hline

polynomial order   & \textit{INTEGER}: Polynomial order to be assigned uniformly to all the elements of the mesh. If the keyword \textit{polynomial order file} is specified, the value of this keyword is overridden. & --* \\ \hline

polynomial order i \

polynomial order j \

polynomial order k & \textit{INTEGER}: Polynomial order in the i, j, or k component for all the elements in the domain. If used, the three directions must be declared explicitly, unless you are using a polynomial order file. If the keyword \textit{polynomial order file} is specified, the value of this keyword is overridden. & --* \\ \hline

polynomial order file  & \textit{CHARACTER}: Path to a file containing the polynomial order of each element in the domain. & --* \\ \hline

restart 			& \textit{LOGICAL}: If .TRUE., initial conditions of simulation will be read from restart file specified using the keyword \textit{restart file name}. \textbf{THIS SHOULD NOT BE MANDATORY... DEFAULT FALSE WOULD BE EASIER}. & \textbf{Mandatory keyword} \\ \hline

cfl & \textit{REAL}: A constant related with the \textbf{convective} Courant-Friedrichs-Lewy (CFL) condition that the program will use to compute the time step size. & --** \\ \hline

dcfl & \textit{REAL}: A constant related with the \textbf{diffusive} Courant-Friedrichs-Lewy (DCFL) condition that the program will use to compute the time step size. & --** \\ \hline

dt  & \textit{REAL}: Constant time step size.  & --** \\ \hline

final time  & \textit{REAL}: This keyword is mandatory for time-accurate solvers & -- \\ \hline

mesh file name & \textit{CHARACTER}: Name of the mesh file. The currently supported formats are \textit{.mesh} (SpecMesh file format) and \textit{.h5} (HOPR hdf5 file format). & \textbf{Mandatory\ keyword} \\ \hline

mesh inner curves & \textit{LOGICAL}: Specifies if the mesh reader must suppose that the inner surfaces (faces connecting the elements of the mesh) are curved. This input variable only affects the hdf5 mesh reader. & .TRUE. \\ \hline

number of time steps & \textit{INTEGER}: \textit{Maximum} number of time steps that the program will compute.  & \textbf{Mandatory\ keyword} \\ \hline

output interval   & \textit{INTEGER}: In steady-state, this keyword indicates the interval of time steps to display the residuals on screen. In time-accurate simulations, this keyword indicates how often a 3D output file must be stored.  & \textbf{Mandatory\ keyword} \\ \hline

convergence tolerance & \textit{real}: \textbf{WHY MANDATORY?.. ONLY USED FOR STEADY-STATE}  & \textbf{Mandatory\ keyword} \\ \hline

manufactured solution & \textit{CHARACTER}: Must have the value '2D' or '3D'. When this keyword is used, the program will add source terms for the conservative variables taken into account an exact analytic solution for each primitive variable j ($\rho$, $u$, $v$, $w$, $p$) of the form:\
 
$j = j_C(1) + j_C(2) \sin(\pi j_C(5) x) + j_C(3) \sin(\pi j_C(6) y) + j_C(4) \sin(\pi j_C(7) z) $\

Where $j_C(i)$ are constants defined in the file \textit{ManufacturedSolutions.f90}. Proper initial and boundary conditions must be imposed (see the test case). The mesh must be a unit cube.
  & -- \\ \hline

Number of boundaries & \textit{INTEGER}: Specifies the number of boundaries of the geometry. This keyword must be followed by an equal number of lines in the control file that define the boundary conditions as follows: \ 

\begin{center}
\textit{boundaryName1 boundaryValue1 boundaryType1} \ 

\textit{boundaryName2 boundaryValue2 boundaryType2} \

\textit{...} 
\end{center}
& \textbf{Mandatory keyword} \\ \hline

\multicolumn{3}{p{16.4cm}}{*  At least one of these two keywords must be specified} \\

\multicolumn{3}{p{16.4cm}}{** For Euler simulations, the user must specify either the CFL number or the time-step size. For Navier-Stokes simulations, the user must specify the CFL and DCFL numbers \textbf{or} the time-step size.}

\end{longtable}

\chapter{Restarting a Case}

\begin{table}[htbp]
\caption{Keywords for restarting a case.}
\begin{tabular}{|l|p{10cm}|p{2.2cm}|}
\hline
\multicolumn{1}{|c|}{Keyword} & \multicolumn{1}{c|}{Description} & \multicolumn{1}{c|}{Default value} \\ \hline

restart 			& \textit{LOGICAL}: If .TRUE., initial conditions of simulation will be read from restart file specified using the keyword \textit{restart file name}. & \textbf{Mandatory keyword} \\ \hline

restart file name   & \textit{CHARACTER}: Name of the restart file to be written and, if keyword \textit{restart} = .TRUE., also name of the restart file to be read for starting the simulation. & \textbf{Mandatory\ keyword} \\ \hline

restart interval    & \textit{INTEGER}: Indicates how often restart files have to be written. & Huge number \\ \hline

restart polorder & \textit{INTEGER}: Uniform polynomial order of the solution to restart from. This keyword is only needed when the restart solution is of a different order than the current case. & same as case's \\ \hline

restart polorder file & 
			\textit{CHARACTER}: File containing the polynomial orders of the solution to restart from. This keyword is only needed when the restart solution is of a different order than the current case.  &  same as case's\\ \hline

get discretization error of & \textit{CHARACTER}: Path to solution file. This can be used to estimate the discretization error of a solution when restarting from a higher-order solution. & -- \\ \hline

\end{tabular}
\label{tab:restartkey}
\end{table}


\chapter{Implicit Solvers}
\section{General Keywords}
The keywords for the implicit solvers are listed in table \ref{tab:implicitkey}

%\begin{table}[htbp]
%\caption{Keywords for implicit solvers.}
%\begin{tabular}{|l|p{10cm}|p{2.2cm}|}
%\hline
%\multicolumn{1}{|c|}{Keyword} & \multicolumn{1}{c|}{Description} & \multicolumn{1}{c|}{Default value} \\ \hline

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for implicit solvers.} \label{tab:implicitkey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for implicit solvers - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

\textbf{time integration} & \textit{CHARACTER}: This is the main keyword for activating the implicit solvers. The value of it should be set to 'implicit'. & 'explicit' \\ \hline

jacobian flag           & \textit{INTEGER}: Specifies the type of Jacobian matrix to be computed. Options are:\
				\begin{enumerate}
					\item Numerical Jacobian: Uses coloring algorithm for computing Jacobian.
					\item Analytical Jacobian: Being implemented. To date only available for the compressible Euler equations and 'matrix-free smooth' linear solver to compute the blocks of the Jacobian.
					\end{enumerate}
										& 1 \\ \hline

jacobian by convergence & \textit{LOGICAL}: When .TRUE., the Jacobian is only computed when the convergence falls beneath some threshold (see keyfords: blah and blah blah). This improves performance but can introduce big numerical errors for time-accurate simulations.  & .FALSE. \\ \hline

linear solver           & \textit{CHARACTER}: Specifies the linear solver that has to be used. Options are:\ 
				\begin{itemize}
					\item 'petsc': PETSc library Krylov-Subspace methods.
					\item 'pardiso': Intel MKL PARDISO.
					\item 'matrix-free gmres': A matrix-free version of the GMRES algorithm. Can be used without preconditioner or with a recursive GMRES preconditioner using 'preconditioner=GMRES'.
					\item 'smooth': Traditional iterative methods. One can select either 'smoother=WeightedJacobi' or 'smoother=BlockJacobi'.
					\item 'matrix-free smooth': A matrix-free version of the previous solver. Only available eith 'smoother=BlockJacobi'
					\item 'multigrid': .
				\end{itemize}
										& 'petsc'  \\ \hline
print newton info       & \textit{LOGICAL}: If .TRUE., the information of the Newton iterations will be displayed. &  '.FALSE.'\\ \hline
implicit adaptive dt  & \textit{LOGICAL}: Specifies if the time-step should be computed according to the convergence behavior of the Newton iterative method and the linear solver. & .FALSE. \\ \hline
newton tolerance   & \textit{REAL}: Specifies the tolerance for the Newton method. &  $10^{-6}$ or for time-accurate simulations and  $MaxResidual \times 10^{-3}$ for steady-state simulations \\ \hline
    &  &  \\ \hline
    
\end{longtable}

\section{Multigrid}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for the multigrid solver.} \label{tab:multigridKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the multigrid solver - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead


multigrid levels & \textit{INTEGER}: Number of multigrid levels for the computations. & \textbf{Mandatory keyword} \\ \hline

delta n          & \textit{INTEGER}: Interval of reduction of polynomial order for creating coarser multigrid levels.& 1 \\ \hline

multigrid output & \textit{LOGICAL}: If .TRUE., the residuals at the different multigrid levels will be displayed. & .FALSE. \\ \hline
   
    &  &  \\ \hline
\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{p-Adaptation Methods}
The p-adaptation methods are used when the p-adaptation region is specified in the control file:\\

\begin{lstlisting}
#define p-adaptation
   Truncation error type = isolated
   truncation error      = 1.d-2
   Nmax                  = [10,10,10]
   Nmin                  = [2 ,2 ,2 ]
   Conforming boundaries = [InnerCylinder,sphere]
   order across faces    = N*2/3   
   increasing            = .FALSE.
   regression files      = .FALSE.
   adjust nz             = .FALSE.
   mode                  = time
   interval              = 1.d0   
   restart files         = .TRUE.
   padapted mg sweeps pre      = 10
   padapted mg sweeps post     = 12
   padapted mg sweeps coarsest = 20
#end
\end{lstlisting}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for the p-adaptation algorithms.} \label{tab:pAdaptationKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the p-adaptation algorithms - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

truncation error type & \textit{CHARACTER}: Can be either "isolated" or "non-isolated". & isolated \\ \hline

truncation error & \textit{REAL}: Target truncation error for the p-adaptation algorithm. & \textbf{Mandatory keyword} \\ \hline

Nmax          & \textit{INTEGER}(3): Maximum polynomial order in each direction for the p-adaptation algorithm. & 
					\textbf{Mandatory keyword} \\ \hline

Nmin          & \textit{INTEGER}(3): Minimum polynomial order in each direction for the p-adaptation algorithm. & 
					[1,1,1] \\ \hline

conforming boundaries & \textit{CHARACTER}(*): Specifies the boundaries of the geometry that must be forced to be conforming after the p-adaptation process.  	  & 
					-- \\ \hline

order across faces &
			\textit{CHARACTER}: Mathematical expression to specify the maximum polynomial order jump across faces. Currently, only $N*2/3$ and $N-1$ are supported. &
					$N-1$ \\ \hline 

increasing & \textit{LOGICAL}: If .TRUE. the multi-stage FMG adaptation algorithm is used. & 
					.FALSE. \\ \hline

regression files &
			\textit{LOGICAL}: If .TRUE., the program writes files containing the information about the lin-log regression procedure that is performed for the $\tau$-estimation extrapolation. The files are stored in the folder \textit{./RegressionFiles/Stage\_XX/}, where \textit{XX} is the adaptation stage number. & 
			 		.FALSE. \\ \hline

adjust nz & 
			\textit{LOGICAL}: If .TRUE., the order accross faces is adjusted i    n the directions xi, eta, and zeta of the face (being zeta the normal direction). If .FALSE., the     order is only adjusted in the xi and eta directions. The adjustment currently consists (hard-cod    ed) in allowing jumps in the polynomial order of at most 1. & 
					.FALSE. \\ \hline

mode & 
			\textit{CHARACTER}: p-Adaptation mode. Can be \textit{steady}, \textit{time} or \textit{iteration}. Steady p-adaptation is performed once at the beginning of a simulation. Unsteady adaptation can be by \textit{time} or by \textit{iteration}. &
					\textit{steady} \\ \hline

interval & 
			\textit{INTEGER/REAL}: In unsteady p-adaptation cases, this keyword specifies the iteration (integer) or time (real) interval for p-adaptation. &
					\textit{huge number} \\ \hline

restart files & 
			\textit{LOGICAL}: If .TRUE., the program writes restart files before and after the p-adaptation. &
					.FALSE. \\ \hline

padapted $\ll \textit{keyword} \gg$ &
			\textit{MULTIPLE}: Specifies control file keywords that should be replaced after the adaptation procedure. Currently, only 'mg sweeps         ', 'mg sweeps pre', 'mg sweeps post', and 'mg sweeps coarsest' are supported. &
					-- \\ \hline

\end{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Monitors}



\section{Statistics Monitor}

\section{Probes}

\begin{lstlisting}
#define probe 1
   name     = SomeName
   variable = SomeVariable
   position = [0.d0, 0.d0, 0.d0]
#end
\end{lstlisting}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for probes.} \label{tab:ProbesKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the p-adaptation algorithms - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

name 	& 
			\textit{CHARACTER}: Name of the monitor. & 
							\textbf{Mandatory Keyword} \\ \hline

variable 	& 
			\textit{CHARACTER}: Variable to be monitored. Implemented options are:\
\begin{itemize}
\item pressure
\item velocity
\item u
\item v
\item w
\item mach
\item k
\end{itemize}			
			
			 & 
							\textbf{Mandatory Keyword} \\ \hline

position 	& 
			\textit{REAL(3)}: Coordinates of the point to be monitored. & 
							\textbf{Mandatory Keyword} \\ \hline
\end{longtable}


\section{Surface Monitors}

\section{Volume Monitors}
Volume monitors compute the average of a quantity in the whole domain. They can be scalars(s) or vectors(v). 

\begin{lstlisting}
#define volume monitor 1
   name     = SomeName
   variable = SomeVariable
#end
\end{lstlisting}

\begin{longtable}{|p{4cm}|p{10cm}|p{2.2cm}|}
\caption{Keywords for volume monitors.} \label{tab:VolMonitorsKey} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endfirsthead

\caption{Keywords for the p-adaptation algorithms - continued.} \\
\hline
\multicolumn{1}{|c|}{\textbf{Keyword}} & \multicolumn{1}{c|}{\textbf{Description}} & \multicolumn{1}{c|}{\textbf{Default value}} \\ \hline
\endhead

name 	& 
			\textit{CHARACTER}: Name of the monitor. & 
							\textbf{Mandatory Keyword} \\ \hline

variable 	& 
			\textit{CHARACTER}: Variable to be monitored. Implemented options are:\
\begin{itemize}
\item[\textbf{(s)}] kinetic energy
\item[\textbf{(s)}] kinetic energy rate
\item[\textbf{(s)}] enstrophy
\item[\textbf{(s)}] entropy
\item[\textbf{(s)}] entropy rate
\item[\textbf{(s)}] mean velocity
\item[\textbf{(v)}] velocity
\item[\textbf{(v)}] momentum
\end{itemize}			
			
			 & 
							\textbf{Mandatory Keyword} \\ \hline


\end{longtable}


\bibliography{../LaTeX/9_backmatter/library}

\end{document}

